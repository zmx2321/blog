pinia和vuex的区别
 Pinia和Vuex都是在Vue.js应用中用于管理应用状态的库，但是它们有以下区别：

API风格：Pinia采用基于函数API的风格，Vuex采用基于对象API的风格。

TypeScript支持：Pinia天生支持TypeScript，而Vuex需要额外安装TypeScript支持。

性能：Pinia通过利用Vue 3中的新特性来提高性能，比如使用reactive来管理状态，让你能够避免使用Vue 2中的Dep对象。相比之下，Vuex使用了更复杂的数据结构，并使用了Vue 2中的Dep对象
，因此相对来说性能相对较低。

动态加载：Pinia支持动态加载模块，而Vuex需要在应用启动时加载所有模块。

模块初始化：在Vuex中，模块需要在应用启动时初始化，而在Pinia中，模块是在需要时动态创建的。

总的来说，Pinia更加轻量化，可以提供更好的性能，而Vuex则提供了更多的开箱即用的功能和更广泛的社区支持。选择哪一个取决于您的具体需求。

Vue2.0 和 Vue3.0 有什么区别？
 Vue2.0和Vue3.0是Vue.js的两个主要版本，它们有以下区别：

性能提升：Vue3.0通过使用Proxy代替Object.defineProperty来实现响应式数据绑定，提高了性能。

更好的类型推断：Vue3.0使用TypeScript重写了代码，提供了更好的类型推断和类型约束。

更小的包体积：Vue3.0通过删除不必要的代码和更好的树摇动优化，实现了更小的包体积。

模板编译器升级：Vue3.0的模板编译器使用了全新的编译器框架，提高了编译性能和编译错误的反馈。

更好的可组合性：Vue3.0引入了Composition API，提供了更好的可组合性和复用性。

更好的开发体验：Vue3.0提供了更好的开发工具和开发体验，如更好的错误处理和更好的调试工具等等。

总的来说，Vue3.0相比于Vue2.0具有更高的性能，更好的可组合性，更好的开发体验和更小的包体积等优势。但是，由于Vue3.0引入了一些新的特性和修改了一些原有的API，因此与Vue2.0在语法和使用方面存在一些差异，需要开发者进行适当的学习和转换。


简述下setup 参数
 Vue 3 的 setup 参数是用于 Composition API 的一种特殊函数，它可以用于在组件内部定义可复用的逻辑代码。这些逻辑代码可以使用 ref、reactive、computed 等响应式 API 来定义数据，并且可以使用 watch、onMounted 等生命周期函数来处理副作用。

下面是一些常用的 setup 参数：

props：定义从父组件中接收的属性；
context：组件上下文对象，包含父组件、子组件等信息；
setup：定义组件逻辑的函数；
data：定义组件内部数据的函数；
computed：定义计算属性的函数；
methods：定义组件方法的对象；
watch：定义响应式数据的监听器。
在 Vue 3 中，setup 函数是必须的，且在创建组件实例之前先执行一次。setup 函数可以接收两个参数：props 和 context。其中，props 是一个响应式对象，用于接收来自父组件的属性，并且可以使用 ref 或 reactive 包装其中的属性；context 是一个常规 JavaScript 对象，包含一些常用的组件上下文信息。



toRef与toRefs分别什么
 toRef 和 toRefs 都是 Vue3 的响应式 API。它们用于将非响应式对象转换成响应式对象。

toRef 的作用是将一个普通的对象属性转换成一个响应式对象属性，返回一个 ref 对象，使得可以在模板中使用这个 ref 对象来渲染和响应式更新。

toRefs 的作用是将一个普通的对象转换成多个 ref 对象，每个 ref 对象对应原对象的一个属性，使得可以在模板中使用这些 ref 对象来渲染和响应式更新。toRefs 函数返回的是一个包含多个 ref 对象的响应式对象。

toRef 和 toRefs 的区别在于：

toRef 只能将一个普通的对象属性转换成 ref 对象，而 toRefs 可以将整个对象转换成多个 ref 对象。
toRef 返回的是一个 ref 对象，而 toRefs 返回的是一个包含多个 ref 对象的响应式对象。


Object.defineProperty与Proxy有什么区别
 Object.defineProperty与Proxy都可以用来拦截JavaScript对象的操作，但是二者还是有一些区别的。

功能不同：Object.defineProperty主要用于拦截单个属性的读取、写入和删除操作，而Proxy可以拦截所有对象操作，包括属性访问、赋值、函数调用等等。

操作方式不同：Object.defineProperty需要对每个属性进行设置，而Proxy可以对整个对象进行拦截，拦截器只需要实现对应的操作即可。

兼容性不同：Object.defineProperty从ES5开始支持，而Proxy从ES6开始支持。早期的浏览器可能不支持Proxy。

使用场景不同：Object.defineProperty一般用于对已有对象进行改造，而Proxy则更适合在对象创建时就进行拦截，或者对已有的复杂对象进行拦截。

总体来说，Object.defineProperty更加简单易用，而Proxy功能更加强大，但使用也更加复杂。根据具体需求，可以选择使用对应的方法。


组合式api有哪些
 Vue 3引入了全新的基于函数的组合式API。以下列出了一些Vue 3组合式API：

setup()：组件选项之一，在组件实例化之前执行，用来进行组件的初始化。可以在这里定义响应式的数据、计算属性、方法、生命周期钩子等。

reactive()：接受一个对象作为参数，返回一个响应式的数据对象。

ref()：接受一个初始值作为参数，返回一个包装对象，可以通过.value属性访问和更改这个值。

watchEffect()：接受一个响应式数据或计算属性作为参数，当这个数据改变时会自动执行回调函数。

computed()：接受一个函数作为参数，返回一个计算属性。当计算属性依赖的响应式数据改变时会重新计算该属性的值。

watch()：接受一个响应式数据或计算属性作为参数，当这个数据改变时会执行回调函数。

toRefs()：将一个响应式数据对象转换为一个由响应式数据组成的对象。

onMounted()：在组件挂载后执行的生命周期钩子。

onUpdated()：在组件更新后执行的生命周期钩子。

onUnmounted()：在组件卸载前执行的生命周期钩子。

总之，Vue 3中的组合式API更加灵活和直观，可以更好地进行组件的封装和复用。


什么是自定义hook
 Vue3的自定义hook是基于Vue3的组合式API而实现的。通过自定义hook，我们可以将一些常用的逻辑（如数据获取、状态管理等）封装成一个函数，以便在不同组件中复用，避免重复的代码和逻辑。


 Vue2与vue3双向数据绑定原理不同
Vue2和Vue3的双向数据绑定原理不同。

在Vue2中，双向数据绑定是通过使用数据劫持来实现的。数据劫持是指通过Object.defineProperty()方法对对象的属性进行劫持，从而实现对该属性的监听和响应。在Vue2中，当数据发生变化时，系统会自动触发setter函数，并通知相关的组件进行更新。

在Vue3中，双向数据绑定是通过使用Proxy代理来实现的。Proxy代理是ES6的新特性，可以代理一个对象并跟踪该对象的变化。在Vue3中，当数据发生变化时，系统会通过Proxy代理来捕获新的值，从而触发相关的组件进行更新。

总的来说，Vue2和Vue3的双向数据绑定实现原理不同，但都能实现数据和视图的自动更新。Vue3中使用Proxy代理的方式比Vue2的数据劫持更加灵活和高效，但需要考虑浏览器兼容性。



v-if与v-for优先级
 在 Vue 2 中，v-for 的优先级高于 v-if。这意味着当一个元素同时具有 v-if 和 v-for 指令时，v-for 将首先运行，然后再运行 v-if。

例如：

<div v-for="item in items" v-if="item.isActive">{{ item.name }}
</div>
在上面的示例中，如果没有 isActive 属性或值为 false，则渲染的 div 元素将不会被显示，但是 v-for 指令仍然会运行.

在Vue 3中，v-if 和 v-for 的顺序被改变了。如果一个元素拥有 v-if 和 v-for 指令，那么 v-if 将会首先被解析和执行，而 v-for 则会在 v-if 的条件为 true 的情况下才会被执行循环渲染


简述下插槽， 普通插槽、具名插槽和作用域插槽
 插槽是一种可以在组件中填充内容的占位符，可以让父组件向子组件传递内容。

普通插槽是组件中最简单的一种插槽，也叫默认插槽。当父组件没有向子组件传入具体内容时，插槽中的默认内容就会被渲染出来。

具名插槽可以有不同的名称，使得父组件可以向子组件传入多个不同的内容。在子组件中，使用<slot>标签的name属性指定具名插槽的名称，在父组件中使用<template>标签的v-slot指令来传入内容。

作用域插槽是一种可以在子组件中对插槽内容进行处理的插槽。在子组件中，可以使用<slot>标签的name属性指定作用域插槽的名称，并且可以使用<slot>标签的v-bind指令将子组件中的数据传入插槽内容中。在父组件中，则可以在<template>标签的v-slot指令中使用slot-scope来获取子组件中传递进来的数据，并对插槽内容进行处理。


选项式api与组合式api生命周期钩子函数分别是什么
 选项式 API 的生命周期钩子函数如下：

beforeCreate：组件实例刚创建，数据观测和事件配置之前。
created：组件实例已经创建完成，数据观测和事件配置已完成。
beforeMount：组件挂载前调用，相关的 render 函数首次被调用。
mounted：组件挂载完成后调用，此时挂载的 DOM 元素可访问。
beforeUpdate：组件更新前调用，数据强制更新之前。
updated：组件更新完成后调用，此时组件 DOM 已更新。
activated：被 keep-alive 缓存的组件激活时调用。
deactivated：被 keep-alive 缓存的组件停用时调用。
beforeDestroy：组件销毁前调用，实例仍然可用。
destroyed：组件销毁后调用，此时实例已经被完全销毁。
组合式 API 的生命周期钩子函数与选项式 API 大致相同，但是钩子函数名称上有所不同。具体如下：

onBeforeMount：组件挂载前调用，相关的 render 函数首次被调用。
onMounted：组件挂载完成后调用，此时挂载的 DOM 元素可访问。
onBeforeUpdate：组件更新前调用，数据强制更新之前。
onUpdated：组件更新完成后调用，此时组件 DOM 已更新。
onBeforeUnmount：组件销毁前调用，实例仍然可用。
onUnmounted：组件销毁后调用，此时实例已经被完全销毁。


